/*

all architectures must define the following types:

- USize: pointer-sized unsigned integer type
- ISize: pointer-sized signed integer type

all architectures must define the following constants:

- FLASH_ADDR: i32:  boot flash address, used by the bootloader
- MEM_ADDR: i32:    physical memory start address
- CLINT_MTIME: i32: address of CLINT's 'mtime' register
- CLINT_MCMP: i32:  address of CLINT's 'mtimecmp' register

all architectures must define the following functions:

- initIO: ():         initialize IO driver (like UART)
- putChar: (u8):      put a character to IO
- getChar: (): i32:   get a character from IO
- halt: (i32):        halt the CPU, and return exit code (if possible)

*/


// use this architecture as target
public import arch.virt

// some constants about RISC-V
// machine status register
inline let MSTATUS_MPP_MASK = (3 << 11) as USize
inline let MSTATUS_MPP_M    = (3 << 11) as USize
inline let MSTATUS_MPP_S    = (1 << 11) as USize
inline let MSTATUS_MPP_U    = (0 << 11) as USize
inline let MSTATUS_MIE      = (1 << 3) as USize
// supervisor status register
inline let SSTATUS_SUM      = (1 << 18) as USize
inline let SSTATUS_SPP      = (1 << 8) as USize
inline let SSTATUS_SPIE     = (1 << 5) as USize
inline let SSTATUS_UPIE     = (1 << 4) as USize
inline let SSTATUS_SIE      = (1 << 1) as USize
inline let SSTATUS_UIE      = (1 << 0) as USize
// supervisor interrupt enable
inline let SIE_SEIE         = (1 << 9) as USize
inline let SIE_STIE         = (1 << 5) as USize
inline let SIE_SSIE         = (1 << 1) as USize
// machine-mode interrupt enable
inline let MIE_MEIE         = (1 << 11) as USize
inline let MIE_MTIE         = (1 << 7) as USize
inline let MIE_MSIE         = (1 << 3) as USize
// supervisor address translation and protection
inline let SATP_SV32        = (1 << 31) as USize
// trap cause
inline let TRAP_S_SOFT_INT  = ((1 << 31) | 1) as USize
inline let TRAP_ILLEGAL     = 2 as USize
inline let TRAP_INST_FAULT  = 12 as USize
inline let TRAP_LOAD_FAULT  = 13 as USize
inline let TRAP_STORE_FAULT = 15 as USize
// page-based virtual memory
inline let PAGE_SIZE        = 4096  // bytes per page
inline let PAGE_PTE_SIZE    = 4     // bytes per PTE
inline let PAGE_SHIFT       = 12    // bytes of offset within a page
inline let PAGE_PTE_COUNT   = PAGE_SIZE / PAGE_PTE_SIZE
inline let PAGE_ATTR_V      = 1 << 0                // valid
inline let PAGE_ATTR_R      = 1 << 1                // read-only
inline let PAGE_ATTR_E      = 1 << 3                // executable
inline let PAGE_ATTR_WR     = (1 << 1) | (1 << 2)   // writable & readable

// declarations of functions in 'arch.S'
extern declare getMstatus: (): USize
extern declare setMstatus: (USize)
extern declare setMepc: (USize)
extern declare getSstatus: (): USize
extern declare setSstatus: (USize)
extern declare getSip: (): USize
extern declare setSip: (USize)
extern declare getSie: (): USize
extern declare setSie: (USize)
extern declare getMie: (): USize
extern declare setMie: (USize)
extern declare setSepc: (USize)
extern declare getSepc: (): USize
extern declare getMedeleg: (): USize
extern declare setMedeleg: (USize)
extern declare getMideleg: (): USize
extern declare setMideleg: (USize)
extern declare setStvec: (USize)
extern declare getStvec: (): USize
extern declare setMtvec: (USize)
extern declare setSatp: (USize)
extern declare getSatp: (): USize
extern declare setSscratch: (USize)
extern declare setMscratch: (USize)
extern declare getScause: (): USize
extern declare getStval: (): USize
extern declare getSp: (): USize
extern declare getRa: (): USize
extern declare runSfence: ()

// just halt, returns nothing
inline def halt() {
  halt(0)
}

// enable devide interrupts
inline def setIntrOn() {
  setSie(getSie() | SIE_SEIE | SIE_STIE | SIE_SSIE)
  setSstatus(getSstatus() | SSTATUS_SIE)
}

// disable device interrupts
inline def setIntrOff() {
  setSstatus(getSstatus() & ~SSTATUS_SIE)
}

// check if device interrupts are enabled
inline def getIntr(): bool {
  (getSstatus() & SSTATUS_SIE) != 0 as USize
}

// round up address to page boundary
inline def roundUpPage(addr: USize): USize {
  (addr + (PAGE_SIZE - 1) as USize) & (~(PAGE_SIZE - 1) as USize)
}

// round down address to page boundary
inline def roundDownPage(addr: USize): USize {
  addr & (~(PAGE_SIZE - 1) as USize)
}

// get 'vpn[1]' field of virtual address
inline def getVpn1(addr: USize): USize {
  addr >> 22 as USize
}

// get 'vpn[0]' field of virtual address
inline def getVpn0(addr: USize): USize {
  (addr >> 12 as USize) & 0x3ff as USize
}

// convert physical address to PTE
inline def convPaddrPte(addr: USize): USize {
  (addr >> 12 as USize) << 10 as USize
}

// convert PTE to physical address
inline def convPtePaddr(pte: USize): USize {
  (pte >> 10 as USize) << 12 as USize
}

// make SATP value
inline def makeSatp(pt_addr: USize): USize {
  (pt_addr >> 12 as USize) | SATP_SV32
}
