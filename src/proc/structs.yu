public import define.context
public import mem.mset
public import fs.info
public import proc.consts

import arch.arch
import arch.riscv.consts
import arch.riscv.csr
import mem.pm
import mem.heap
import mem.attr
import mem.handler
import lib.except
import lib.elf
import lib.c.string
import lib.io
import proc.consts

// size of kernel stack
// must be page size because stack is allocated by frame allocator
let STACK_SIZE  = PAGE_SIZE as USize

// definition of kernel thread stack
public struct KernelStack {
  addr: u8 var*,
}

// create new kernel stack
public def newKernelStack(): KernelStack {
  let addr = allocPhyMem()
  assert(addr as i32 != 0, "newKernelStack - OOM")
  [KernelStack] {addr}
}

// release kernel stack
public def del(this: KernelStack var&) {
  if this.addr as i32 != 0 {
    freePhyMem(this.addr)
  }
  this.addr = null as u8 var*
}

// get top of kernel stack
public def getTop(this: KernelStack&): USize {
  this.addr as USize + STACK_SIZE
}


// definition of process
public struct Process {
  vm: MemorySet,
  fds: FileInfo,
  thread_count: i32,
}

def newProcess(vm: MemorySet): Process var* {
  let proc = allocHeapMem(sizeof Process) as Process var*
  (*proc).vm = vm
  (*proc).fds.init()
  (*proc).thread_count = 0
  proc
}

def del(this: Process var*) {
  // TODO: release all allocated pages
  (*this).fds.del()
  freeHeapMem(this as u8 var*)
}

def incCounter(this: Process var*): Process var* {
  (*this).thread_count += 1
  this
}

def decCounter(this: Process var*): Process var* {
  (*this).thread_count -= 1
  if (*this).thread_count < 0 {
    panic("decCounter")
  }
  else if (*this).thread_count == 0 {
    this.del()
  }
  this
}

def getFds(this: Process var*): FileInfo var& {
  (*this).fds
}


// definition of thread
// objects of this structure will always be allocated on the heap
public struct Thread {
  context: Context,
  kstack: KernelStack,
  proc: Process var*,
  wait: Tid,
}

// create memory attribute by ELF program header
def toAttr(this: Elf32Phdr*): MemoryAttr {
  var attr = newMemoryAttr().setUser()
  if this.isExecute() {
    attr = attr.setExecute()
  }
  attr
}

// create memory set by ELF file
def makeMemorySet(this: ElfFile&): MemorySet {
  // create a new memory set with kernel mapping
  var ms = newMemorySet()
  // traverse program headers in ELF file
  for ph in this.getPhdrIter() {
    if ph.getType() != ElfPtype.Load {
      continue
    }
    // get address info
    let virt_addr = ph.getVaddr(), mem_size = ph.getMemSize()
    // get data of program header
    let data = this.getPhdrData(ph), data_len = ph.getFileSize()
    // get slice of target virtual address
    let target = {
      let frame_handler = newFrameHandler()
      let handler = &frame_handler as MemoryHandler*
      ms.push(virt_addr, virt_addr + mem_size, ph.toAttr(), handler)
      virt_addr as u8 var*
    }
    // copy data to page
    ms.withBegin(); {
      memcpy(target, data, data_len as USize)
      memset(target + data_len, 0, (mem_size - data_len) as USize)
    }; ms.withEnd()
  }
  ms
}

// create new idle thread
public def newIdleThread(): Thread var* {
  let thread = allocHeapMem(sizeof Thread) as Thread var*
  (*thread) = [Thread] {
    newNullContext(),
    newKernelStack(),
    null as Process var*,
    0 as Tid,
  }
  thread
}

// create new kernel thread
public def newKernelThread(entry: USize): Thread var* {
  let kstack = newKernelStack()
  let thread = allocHeapMem(sizeof Thread) as Thread var*
  (*thread) = [Thread] {
    newKernelContext(entry, kstack.getTop(), getSatp()),
    kstack,
    null as Process var*,
    0 as Tid,
  }
  thread
}

// create new user thread
public def newUserThread(data: u8*, wait_thread: Tid): Thread var* {
  let elf = newElfFile(data), ehdr = elf.getEhdr()
  // TODO: do not panic in kernel
  assert(ehdr.isValid(), "failed to read ELF")
  // check ELF type
  assert(ehdr.getType() == ElfEtype.Executable, "unsupported ELF type")
  // get entry point
  let entry = ehdr.getEntry()
  // TODO: remove this log
  io <<< "entry: " <<$ entry <<< '\n'
  // create page table & user stack
  var ms = elf.makeMemorySet()
  let ustack_top = {
    let ustack_bottom = USER_STACK_OFFSET as USize
    let ustack_top = (USER_STACK_OFFSET + USER_STACK_SIZE) as USize
    let frame_handler = newFrameHandler()
    let handler = &frame_handler as MemoryHandler*
    ms.push(ustack_bottom, ustack_top, newMemoryAttr().setUser(), handler)
    ustack_top
  }
  // create kernel stack & user thread
  let kstack = newKernelStack()
  let thread = allocHeapMem(sizeof Thread) as Thread var*
  let proc = newProcess(ms).incCounter()
  (*thread) = [Thread] {
    newUserContext(entry, ustack_top, kstack.getTop(), ms.token()),
    kstack,
    proc,
    wait_thread,
  }
  // initialize stdio
  proc.getFds().initStdFds()
  thread
}

// release current thread structure
public def del(this: Thread var*) {
  (*this).kstack.del()
  if (*this).proc != null as Process var* {
    (*this).proc.decCounter()
  }
  freeHeapMem(this as u8 var*)
}

// append initial arguments for current thread
public def appendInitArgs(this: Thread*, args: USize[3]) {
  (*this).context.appendInitArgs(args)
}

// switch to target thread
public def switchTo(this: Thread var*, target: Thread var*) {
  (*this).context.switchTo((*target).context)
}

// get file info
public def getFds(this: Thread var*): FileInfo var& {
  assert((*this).proc != null as Process var*, "Thread.getFds")
  (*this).proc.getFds()
}

// get wait thread
inline def getWait(this: Thread var*): Tid {
  (*this).wait
}
