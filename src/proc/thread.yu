public import arch.arch
public import proc.consts
public import proc.structs

import proc.processor
import lib.io
import mem.heap
import arch.riscv.csr

// first user program, defined in 'init.S'
extern declare _user_img_start: ()

// current processor
// allocated on heap
var cpu: Processor var*

def helloThread(arg: USize) {
  io <<< "hello thread\n"
  io <<< "arg is " <<< arg <<< '\n'
  // do something
  var i = 0
  while i < 100 {
    io <<< arg <<< arg <<< arg <<< arg <<< arg <<< arg <<< '\n'
    var j = 0
    while j < 1000 {
      j += 1
    }
    i += 1
  }
  // exit thread
  io <<< "end of thread " <<< arg <<< '\n'
  cpu.exit(0 as USize)
}

public def initThread() {
  // initialize cpu
  cpu = allocHeapMem(sizeof Processor) as Processor var*
  cpu.init(TIME_SLICE)
  // create kernel threads
  let hello0 = newKernelThread(helloThread as USize)
  hello0.appendInitArgs([USize[3]] {0 as USize})
  let hello1 = newKernelThread(helloThread as USize)
  hello1.appendInitArgs([USize[3]] {1 as USize})
  let hello2 = newKernelThread(helloThread as USize)
  hello2.appendInitArgs([USize[3]] {2 as USize})
  let hello3 = newKernelThread(helloThread as USize)
  hello3.appendInitArgs([USize[3]] {3 as USize})
  let hello4 = newKernelThread(helloThread as USize)
  hello4.appendInitArgs([USize[3]] {4 as USize})
  cpu.addThread(hello0)
  cpu.addThread(hello1)
  cpu.addThread(hello2)
  cpu.addThread(hello3)
  cpu.addThread(hello4)
  // create user threads
  let user = newUserThread(_user_img_start as u8*)
  cpu.addThread(user)
}

// turn interrupt on and run scheduler on current CPU
public def runCpu() {
  setIntrOn()
  cpu.run()
}

public def tick() {
  cpu.tick()
}

public def exit(code: USize) {
  cpu.exit(code)
}

public def yield() {
  cpu.yield()
}

public def wakeUp(tid: Tid) {
  cpu.wakeUp(tid)
}

public def getCurrentTid(): Tid {
  cpu.getCurrentTid()
}

public def getCurrentThread(): Thread var& {
  cpu.getCurrentThread()
}
