import arch.arch
import arch.riscv.pagetable
import arch.riscv.addr
import arch.riscv.consts
import arch.riscv.csr
import mem.mset
import mem.consts
import mem.pm

// defined in 'pagetable.S'
extern declare switchToVm: (USize)

// set linear mapping of address range
def mapRange(pt: PageTable var*, begin: i32, end: i32,
             va: i32, flags: USize) {
  let begin = begin / MEGAPAGE_SIZE, end = end / MEGAPAGE_SIZE
  let offset = (va - begin) / MEGAPAGE_SIZE
  var addr = begin
  while addr < end + 1 {
    let pa = newPhysAddr((addr * MEGAPAGE_SIZE) as USize)
    let frame = newFrame(pa)
    pt.getPte(pa.getPpn1() + offset as USize).set(frame, flags)
    addr += 1
  }
}

// initialize root page table for kernel
def initRootTable() {
  let root_table = _root_table as PageTable var*
  let flags = PTE_FLAG_V | PTE_FLAG_R | PTE_FLAG_W
  let kernel_len = _geeos_end as i32 - _geeos_start as i32
  // set identity mapping vm(KERNEL_BASE) -> pm(KERNEL_BASE)
  root_table.mapRange(KERNEL_BASE, KERNEL_BASE + kernel_len,
                      KERNEL_BASE, flags | PTE_FLAG_X)
  // set linear mapping vm(KERNEL_VM_BASE) -> pm(KERNEL_BASE)
  root_table.mapRange(KERNEL_BASE, KERNEL_BASE + kernel_len,
                      KERNEL_VM_BASE, flags | PTE_FLAG_X)
  // set identity mapping vm(UART_ADDR) -> pm(UART_ADDR)
  root_table.mapRange(UART_ADDR, UART_END, UART_ADDR, flags)
  // set recursive mapping
  let root_frame = newFrame(newPhysAddr(_root_table as USize))
  root_table.setRecursive(RECURSIVE_INDEX, root_frame)
  // switch to higher address space
  let token = root_frame.getPpn() | SATP_SV32
  switchToVm(token)
}

// remapping kernel address space
def remapKernel() {
  let offset = (KERNEL_VM_BASE - KERNEL_BASE) as ISize
  var mset = newMemSet()
  let linear = newLinearHandler(offset)
  let handler = &linear as MemoryHandler*
  mset.push(_text_start as USize, _text_end as USize,
            newMemAttr().setExecute().setReadonly(), handler)
  mset.push(_rodata_start as USize, _rodata_end as USize,
            newMemAttr().setReadonly(), handler)
  mset.push(_data_start as USize, _data_end as USize,
            newMemAttr(), handler)
  mset.push(_bss_start as USize, _bss_end as USize,
            newMemAttr(), handler)
  mset.push(_stack_start as USize, _stack_end as USize,
            newMemAttr(), handler)
  mset.push(UART_ADDR as USize, UART_END as USize,
            newMemAttr(), handler)
  mset.push(CLINT_ADDR as USize, CLINT_END as USize,
            newMemAttr(), handler)
  mset.activate()
}

public def initMem() {
  // enable user memory access in S-mode
  setSstatus(getSstatus() | SSTATUS_SUM)
  // initialize phyical memory
  initPhyMem()
  // initialize page table
  initRootTable()
  // // remap kernel
  // remapKernel()
}
