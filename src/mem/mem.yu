import arch.arch
import arch.riscv.pagetable
import arch.riscv.addr
import arch.riscv.consts
import arch.riscv.csr
import mem.mset
import mem.consts
import mem.pm
import mem.heap

// set linear mapping of address range
def mapRange(pt: PageTable var*, begin: USize, end: USize, flags: USize) {
  let begin = begin / MEGAPAGE_SIZE as USize
  let end = end / MEGAPAGE_SIZE as USize
  var addr = begin
  while addr <= end {
    let pa = newPhysAddr(addr * MEGAPAGE_SIZE as USize)
    let frame = newFrame(pa)
    pt.getPte(pa.getPpn1()).set(frame, flags)
    addr += 1 as USize
  }
}

// initialize temporary root page table for kernel
// returns temporary allocated root page table
def initTempTable(): PageTable var* {
  let root_table = allocPhyMem() as PageTable var*
  let flags = PTE_FLAG_V | PTE_FLAG_R | PTE_FLAG_W
  root_table.zero()
  // set identity mapping vm(KERNEL_BASE) -> pm(KERNEL_BASE)
  root_table.mapRange(KERNEL_BASE as USize, PHY_STOP as USize,
                      flags | PTE_FLAG_X)
  // set identity mapping vm(UART_ADDR) -> pm(UART_ADDR)
  root_table.mapRange(UART_ADDR as USize, UART_END as USize, flags)
  // set recursive mapping
  let root_frame = newFrame(newPhysAddr(root_table as USize))
  root_table.setRecursive(RECURSIVE_INDEX, root_frame)
  // activate root page table
  setSatp(root_frame.getPpn() | SATP_SV32)
  runSfence()
  root_table
}

// remapping kernel address space
def remapKernel() {
  var mset = newMemorySet()
  let linear = newLinearHandler((KERNEL_VM_BASE - KERNEL_BASE) as ISize)
  let handler = &linear as MemoryHandler*
  mset.push(_text_start as USize, _text_end as USize,
            newMemoryAttr().setExecute().setReadonly(), handler)
  mset.push(_rodata_start as USize, _rodata_end as USize,
            newMemoryAttr().setReadonly(), handler)
  mset.push(_data_start as USize, PHY_STOP as USize,
            newMemoryAttr(), handler)
  mset.push(UART_ADDR as USize, UART_END as USize,
            newMemoryAttr(), handler)
  mset.activate()
}

public def initMem() {
  // enable user memory access in S-mode
  setSstatus(getSstatus() | SSTATUS_SUM)
  // initialize phyical memory
  initPhyMem()
  // initialize heap memory
  initHeapMem()
  // initialize temporary page table
  let temp_table = initTempTable()
  // remap kernel
  remapKernel()
  // free temporary page table
  freePhyMem(temp_table as u8 var*)
}
