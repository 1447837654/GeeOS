import arch.arch
import lib.io
import lib.except
import lib.elf
import lib.c.string

// boot from specific address
extern declare jumpToAddr: (u8*)
def boot(addr: u8*) {
  io <<< "booting from 0x" <<$ addr as u32 <<< "...\n\n"
  jumpToAddr(addr)
}

// load ELF file from specific address to memory
def loadElf(addr: u8*): u8* {
  // read & check ELF file
  let elf = newElfFile(addr)
  let ehdr = elf.getEhdr()
  if !ehdr.isValid() {
    panic("invalid ELF file")
  }
  // copy ELF to RAM
  io <<< "loading ELF...\n"
  for phdr in elf.getPhdrIter() {
    let dst = phdr.getPaddr() as u8 var*
    let src = elf.getPhdrData(phdr)
    memcpy(dst, src, phdr.getFileSize() as USize)
  }
  // get address of entry
  let phdr = elf.getPhdr()
  let off = phdr.getVaddr() - phdr.getPaddr()
  (ehdr.getEntry() - off) as u8*
}

// wait for 0x9e9e9e9e
def waitMagicHeader() {
  var i = 0
  while i < 4 {
    if io.getChar() == 0x9e as u8 {
      i += 1
    }
    else {
      i = 0
    }
  }
}

// read 32-bit word from UART
def readWordFromUart(): u32 {
  var word = io.getChar() as u32
  word |= io.getChar() as u32 << 8 as u32
  word |= io.getChar() as u32 << 16 as u32
  word |= io.getChar() as u32 << 24 as u32
  word
}

// receive data from UART
def receiveFromUart(): u8* {
  // wait header
  io <<< "waiting for u32 sequence: 0x9e9e9e9e OFFSET LEN DATA...\n"
  waitMagicHeader()
  // read offset & len
  let offset = readWordFromUart() as u8 var*, len = readWordFromUart()
  io <<< "offset: 0x" <<$ offset as u32 <<< ", len: " <<< len <<< '\n'
  // receive data
  io <<< "receiving data...\n"
  var i = 0
  while i as u32 < len {
    offset[i] = io.getChar()
    i += 1
  }
  io <<< "done receiving data\n"
  offset
}

extern def entry() {
  initIO()
  io <<< "GeeOS bootloader v0.0.1\n"
  // determine boot mode
  io <<< "boot mode: "
  let addr = if (*(SWITCH_ADDR as i32*) == 0) {
    // boot from flash
    io <<< "flash\n"
    FLASH_ADDR as u8*
  }
  else {
    // boot from UART
    io <<< "UART\n"
    receiveFromUart()
  }
  // load ELF data to memory
  let entry = loadElf(addr)
  // execute ELF data
  io <<< "exiting bootloader...\n"
  boot(entry)
}

extern def handleTrap(mepc: u32, mcause: u32, mtval: u32) {
  // display messsage
  io <<< "  mepc:   0x" <<$ mepc <<< '\n'
  io <<< "  mcause: 0x" <<$ mcause <<< '\n'
  io <<< "  mtval:  0x" <<$ mtval <<< '\n'
  panic("unexpected trap occurred while booting!")
}
