public import fs.vfs.structs
public import lib.except

import mem.heap
import lib.io

// maximum count of inodes
let MAX_INODE_COUNT = 0x10000

inline def getType(this: INode*): INodeType {
  (*this).itype
}

inline def getRefCount(this: INode*): i32 {
  (*this).ref_count
}

inline def getOpenCount(this: INode*): i32 {
  (*this).open_count
}

inline def getVfs(this: INode*): Vfs* {
  (*this).vfs as Vfs*
}

/*
 * check - check the various things being valid
 * called before all other virtual operations
 */
public def check(this: INode*) {
  assert(this != null as INode* && (*this).ops != null as u8*,
         "INode.check")
  let ref_count = this.getRefCount(), open_count = this.getOpenCount()
  assert(ref_count >= open_count && open_count >= 0 &&
         ref_count < MAX_INODE_COUNT && open_count < MAX_INODE_COUNT,
         "INode.check")
}

inline def open(this: INode var*, flags: u32): i32 {
  this.check()
  let ops = (*this).ops as INodeOps*
  assert((*ops).op_open as i32 != 0, "INode.open")
  ((*ops).op_open)(this, flags)
}

inline def close(this: INode var*): i32 {
  this.check()
  let ops = (*this).ops as INodeOps*
  assert((*ops).op_close as i32 != 0, "INode.close")
  ((*ops).op_close)(this)
}

inline def reclaim(this: INode var*): i32 {
  this.check()
  let ops = (*this).ops as INodeOps*
  assert((*ops).op_reclaim as i32 != 0, "INode.reclaim")
  ((*ops).op_reclaim)(this)
}

inline def read(this: INode var*, iob: IoBuf var&): i32 {
  this.check()
  let ops = (*this).ops as INodeOps*
  assert((*ops).op_read as i32 != 0, "INode.read")
  ((*ops).op_read)(this, iob)
}

inline def write(this: INode var*, iob: IoBuf&): i32 {
  this.check()
  let ops = (*this).ops as INodeOps*
  assert((*ops).op_write as i32 != 0, "INode.write")
  ((*ops).op_write)(this, iob)
}

inline def fstat(this: INode var*, state: FileState var&): i32 {
  this.check()
  let ops = (*this).ops as INodeOps*
  assert((*ops).op_write as i32 != 0, "INode.fstat")
  ((*ops).op_fstat)(this, state)
}

inline def create(this: INode var*, name: u8*, excl: bool,
                  inode: INode var* var&): i32 {
  this.check()
  let ops = (*this).ops as INodeOps*
  assert((*ops).op_write as i32 != 0, "INode.create")
  ((*ops).op_create)(this, name, excl, inode)
}

inline def truncate(this: INode var*, len: i32): i32 {
  this.check()
  let ops = (*this).ops as INodeOps*
  assert((*ops).op_write as i32 != 0, "INode.truncate")
  ((*ops).op_truncate)(this, len)
}

/*
 * init - initialize an inode structure
 */
public def init(this: INode var*, vfs: Vfs*, ops: INodeOps*) {
  (*this).ref_count = 1
  (*this).open_count = 0
  (*this).vfs = vfs as u8*
  (*this).ops = ops as u8*
}

/*
 * del - kill a inode structure
 */
public def del(this: INode var*) {
  assert(this.getRefCount() == 0 && this.getOpenCount() == 0,
         "INode.del")
  freeHeapMem(this as u8 var*)
}

/*
 * incRefCounter - increment ref_count
 */
public def incRefCounter(this: INode var*): i32 {
  (*this).ref_count += 1
  (*this).ref_count
}

/*
 * decRefCounter - decrement ref_count
 * calls `reclaim` if the ref_count hits zero
 */
public def decRefCounter(this: INode var*): i32 {
  assert(this.getRefCount() > 0, "INode.decRefCounter")
  (*this).ref_count -= 1
  let ref_count = this.getRefCount()
  if ref_count == 0 {
    let ret = this.reclaim()
    if ret != 0 {
      io <<< "VFS: warning: reclaim: " <<< ret <<< '\n'
    }
  }
  ref_count
}

/*
 * incOpenCounter - increment the open_count
 */
public def incOpenCounter(this: INode var*): i32 {
  (*this).open_count += 1
  (*this).open_count
}

/*
 * decOpenCounter - decrement the open_count
 * calls `close` if the open_count hits zero
 */
public def decOpenCounter(this: INode var*): i32 {
  assert(this.getOpenCount() > 0, "INode.decOpenCounter")
  (*this).open_count -= 1
  let open_count = this.getOpenCount()
  if open_count == 0 {
    let ret = this.close()
    if ret != 0 {
      io <<< "VFS: warning: close: " <<< ret <<< '\n'
    }
  }
  open_count
}
